
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --accent:#5b8cff;
  --btn-size:48px;
}
html, body {
  height: 100%;
  margin: 0;
  background: transparent;
  font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  color: #e6eef8;
}
.wrap {
  max-width: 1000px;
  margin: 2px 0;
  padding: 0;
}

/* Carousel */
.carousel {
  position: relative;
  overflow: hidden;
  border-radius: 18px;
  background: transparent;
  box-shadow: 0 8px 30px rgba(2,6,23,0);
  user-select: none;
}
.track {
  display: flex;
  transition: transform .35s cubic-bezier(.2,.9,.2,1);
  will-change: transform;
}
.slide {
  min-width: 100%;
  padding: 0;
  box-sizing: border-box;
}
.slide-inner {
  border-radius: 14px;
  overflow: hidden;
  background: transparent;
  height: 520px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.slide-inner img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Buttons */
.btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: var(--btn-size);
  height: var(--btn-size);
  border-radius: 50%;
  background: rgba(5,10,30,0.6);
  backdrop-filter: blur(6px);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(255,255,255,0.06);
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(2,6,23,0.6);
  z-index: 10; /* Ensures buttons are above the track */
}
.btn svg {
  width: 20px;
  height: 20px;
  fill: #fff;
}
.btn.left { left: 18px; }
.btn.right { right: 18px; }

/* Dots */
.dots {
  display: flex;
  gap: 8px;
  justify-content: center;
  padding: 12px 0;
}
.dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: rgba(210,210,210,0.8);
  cursor: pointer;
}
.dot.active {
  background: var(--accent);
}

/* Responsive */
@media (max-width:800px){
  .slide-inner{ height:62vw; }
  .btn{ width:40px; height:40px; }
}
</style>
</head>
<body>
<div class="wrap">
  <div id="carousel" class="carousel" aria-roledescription="carousel">
    <div id="track" class="track"></div>
    <button class="btn left" id="prevBtn" aria-label="Previous">
      <svg viewBox="0 0 24 24" focusable="false"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
    </button>
    <button class="btn right" id="nextBtn" aria-label="Next">
      <svg viewBox="0 0 24 24" focusable="false"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z"/></svg>
    </button>
  </div>
  <div id="dots" class="dots" aria-hidden="true"></div>
</div>

<script>
const images = [
    'https://cdn.shopify.com/s/files/1/0055/5525/7434/files/FlightSimulator2024_MhywTQBfg5.png?v=1758797915',
    'https://cdn.shopify.com/s/files/1/0055/5525/7434/files/FlightSimulator2024_qHkbSNNDzR.png?v=1758797913',
    'https://cdn.shopify.com/s/files/1/0055/5525/7434/files/FlightSimulator2024_3bYBXOXy0q.png?v=1758797916'
];

const track = document.getElementById('track');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const dotsWrap = document.getElementById('dots');

let slides = [];
let index = 1;
let isDragging = false;
let startX = 0;
let currentTranslate = 0;
let prevTranslate = 0;
let isMoving = false; // Prevents fast clicks during transition

// Function to create a single slide element
function makeSlide(src, idx){
    const s = document.createElement('div');
    s.className = 'slide';
    const inner = document.createElement('div');
    inner.className = 'slide-inner';
    const img = document.createElement('img');
    img.src = src;
    img.alt = `Slide ${idx + 1}`;
    inner.appendChild(img);
    s.appendChild(inner);
    return s;
}

// Builds the carousel with cloned slides for infinite loop effect
function buildCarousel(){
    track.innerHTML = '';
    const first = makeSlide(images[0], 0);
    const last = makeSlide(images[images.length - 1], images.length - 1);

    // Add cloned last slide to the beginning
    track.appendChild(last.cloneNode(true));
    // Add all original slides
    images.forEach((src, i) => track.appendChild(makeSlide(src, i)));
    // Add cloned first slide to the end
    track.appendChild(first.cloneNode(true));

    slides = Array.from(track.children);

    dotsWrap.innerHTML = '';
    images.forEach((_, i) => {
        const d = document.createElement('div');
        d.className = 'dot';
        d.dataset.i = i;
        d.addEventListener('click', () => goTo(i));
        dotsWrap.appendChild(d);
    });

    index = 1;
    applyTranslate(false);
    updateDots();
    isMoving = false; // Reset the flag after initial setup
}

// Applies the CSS transform to the track
function applyTranslate(animate = true){
    isMoving = true;
    track.style.transition = animate ? 'transform .35s cubic-bezier(.2,.9,.2,1)' : 'none';
    track.style.transform = `translateX(${-index * 100}%)`;
}

// Updates the active state of the dots
function updateDots(){
    const dots = Array.from(dotsWrap.children);
    dots.forEach(d => d.classList.remove('active'));
    const imgIndex = (index - 1 + images.length) % images.length;
    if(dots[imgIndex]) dots[imgIndex].classList.add('active');
}

// Navigates to a specific slide by its index
function goTo(i){
    if(isMoving) return;
    index = i + 1;
    applyTranslate();
    updateDots();
}

// Navigates to the next slide
nextBtn.addEventListener('click', ()=>{
    if(isMoving) return;
    index++;
    applyTranslate();
});

// Navigates to the previous slide
prevBtn.addEventListener('click', ()=>{
    if(isMoving) return;
    index--;
    applyTranslate();
});

// Handles the infinite loop effect after a transition
track.addEventListener('transitionend', ()=>{
    if(index === 0) index = images.length;
    if(index === images.length + 1) index = 1;
    applyTranslate(false);
    updateDots();
    isMoving = false; // Reset flag after transition
});

// --- Drag support ---
const dragStart = (e) => {
    isDragging = true;
    startX = e.clientX || e.touches[0].clientX;
    prevTranslate = -index * track.clientWidth;
    track.style.transition = 'none';
    if (e.pointerId) {
        track.setPointerCapture(e.pointerId);
    }
};

const dragMove = (e) => {
    if (!isDragging) return;
    const currentX = e.clientX || e.touches[0].clientX;
    currentTranslate = prevTranslate + (currentX - startX);
    track.style.transform = `translateX(${currentTranslate}px)`;
};

const dragEnd = (e) => {
    if (!isDragging) return;
    isDragging = false;

    // Calculate which slide to snap to based on drag distance
    const slideWidth = track.clientWidth;
    const movedBy = currentTranslate - prevTranslate;
    const dragDistanceInSlides = movedBy / slideWidth;
    
    // Determine the new index by rounding to the nearest full slide
    index = Math.round(index - dragDistanceInSlides);

    // Ensure the index stays within the valid range for our looping logic
    if (index === 0) index = images.length;
    else if (index > images.length) index = 1;

    applyTranslate(); // Snap to the correct slide

    if (e.pointerId) {
        track.releasePointerCapture(e.pointerId);
    }
    isMoving = false; // Reset the flag after drag ends
};

// Use pointer events for unified mouse and touch handling
track.addEventListener('pointerdown', dragStart);
track.addEventListener('pointermove', dragMove);
track.addEventListener('pointerup', dragEnd);
track.addEventListener('pointercancel', dragEnd);
track.addEventListener('pointerleave', dragEnd);

buildCarousel();
</script>
</body>
</html>
